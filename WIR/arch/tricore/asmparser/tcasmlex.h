/*

   This header file belongs to the

            Hamburg University of Technology (TUHH)
              WCC Intermediate Representation Framework

   and is property of its respective copyright holder. It must neither be used
   nor published even in parts without explicit written permission.

   Copyright 2015 - 2022, Heiko Falk.

   Hamburg University of Technology (TUHH)
   Institute of Embedded Systems
   21071 Hamburg
   Germany

   http://www.tuhh.de/es/esd/research/wcc

*/

/*!
  @file tcasmlex.h
  @brief This file provides the interface of a flex-generated scanner class for
         TriCore assembly code.

  @author Heiko Falk <Heiko.Falk@tuhh.de>
*/


#ifndef _TC_ASMLEX_H
#define _TC_ASMLEX_H


//
// Include section
//

// Include standard headers
#include <iostream>

// Flex expects the signature of yylex to be defined in the macro YY_DECL, and
// the C++ parser expects it to be declared. We can factor both as follows.
#ifndef YY_DECL
#define	YY_DECL                                                                \
  WIR::TC_AsmYacc::token_type WIR::TC_AsmLex::lex(                             \
    WIR::TC_AsmYacc::semantic_type *yylval,                                    \
    WIR::TC_AsmYacc::location_type *yylloc )
#endif

#ifndef __FLEX_LEXER_H
#define yyFlexLexer TC_AsmFlexLexer
#include <FlexLexer.h>
#undef yyFlexLexer
#endif

#include <arch/tricore/asmparser/tcasmyacc.hh>


//
// Header section
//

namespace WIR {

//
// Class forward declarations
//

class TC_AsmContext;


/*!
  @brief Class TC_AsmLex is a class derived from flex's scanner class in order
         to add some extra functionality.

  Flex by itself generates a class called yyFlexLexer that is renamed to
  TC_AsmFlexLexer using the preprocessor macro above. Class TC_AsmLex defines
  its very own yylex() function (using preprocessor macro YY_DECL above), since
  the yylex() function natively generated by flex supports no parameters.

  @author Heiko Falk <Heiko.Falk@tuhh.de>
*/
class TC_AsmLex : public TC_AsmFlexLexer
{

  public:

    //
    // Constructors and destructors.
    //

    /*!
      @brief Default constructor creating a TriCore assembly code scanner.

      @param[in] ctx A reference to the current parser context.
      @param[in] arg_yyin A pointer to an input stream to be processed.
      @param[in] tpl A Boolean denoting whether templates shall be read.
      @param[out] arg_yyout A pointer to an output stream for debug output.

      @author Heiko Falk <Heiko.Falk@tuhh.de>
    */
    TC_AsmLex( TC_AsmContext &ctx, std::istream *arg_yyin = nullptr,
               bool tpl = false, std::ostream *arg_yyout = nullptr );

    /*!
      @brief Destructor.
      @author Heiko Falk <Heiko.Falk@tuhh.de>
    */
    virtual ~TC_AsmLex( void );

    /*!
      @brief setDebug (de-) activates debug output of the scanner if this is
             compiled into the scanner.

      @param[in] d A Boolean specifying whether debug output of the scanner
                   shall be activated or not.

      @author Heiko Falk <Heiko.Falk@tuhh.de>
    */
    void setDebug( bool d = true );

    /*!
      @brief lex is the main lexing function.

      Thie method is generated by flex according to the declaration of macro
      YY_DECL above. The generated bison parser then calls this virtual function
      to fetch new tokens.

      @param yylval A pointer to a place where to store semantic information
                    about the current token.
      @param yylloc A pointer to location data for the current token.
      @return The current token.

      @author Heiko Falk <Heiko.Falk@tuhh.de>
    */
    virtual TC_AsmYacc::token_type lex( TC_AsmYacc::semantic_type *yylval,
                                        TC_AsmYacc::location_type *yylloc );


  private:

    //! mContext stores a reference to the current parser context.
    TC_AsmContext &mContext;

    //! mHasTemplates stores whether template arguments have to be processed.
    bool mHasTemplates;

};

}       // namespace WIR

#endif  // _TC_ASMLEX_H
